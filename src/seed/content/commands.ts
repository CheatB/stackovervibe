import {
  heading,
  paragraph,
  codeBlock,
  list,
  quote,
  hr,
  root,
} from "../lexical";

export interface EnrichedContent {
  slug: string;
  description: ReturnType<typeof root>;
  seoTitle: string;
  seoDescription: string;
}

export const enrichedCommands: EnrichedContent[] = [
  // ─────────────────────────────────────────────────────────
  // 1. /new-project
  // ─────────────────────────────────────────────────────────
  {
    slug: "new-project-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/new-project** запускает непрерывный пайплайн из 7 фаз: от чистого VPS до работающего продукта на проде. Команда не просто генерирует шаблон — она проводит глубинное интервью, пишет спецификации, декомпозирует задачи и реализует их через агентов. Результат: рабочий продукт с документацией, тестами и SSL.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Запуск нового проекта
/new-project

# Claude спросит в интерактивном режиме:
# > Опишите ваш проект
# > Какую проблему решает?
# > Кто целевая аудитория?
# Дальше всё автоматически.`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "**Фаза 0: Инфраструктура** — настройка VPS, Docker, Nginx, получение SSL через certbot",
          "**Фаза 1: User Spec** — глубинное интервью с пользователем, фиксация требований и ограничений scope",
          "**Фаза 2: Tech Spec** — выбор стека, архитектура, схема данных, API-контракты",
          "**Фаза 3: Декомпозиция** — разбивка на блоки, wave-параллелизм, оценка времени",
          "**Фаза 4: Реализация** — Team Lead координирует субагентов, чекпоинты после каждого блока",
          "**Фаза 5: Тестирование** — 14 проверок качества: unit, integration, E2E, Lighthouse",
          "**Фаза 6: Финализация** — QA, деплой, документация Project Knowledge, коммит",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Телеграм-бот с подпиской"),
      paragraph(
        'Вы описываете бота кратко: "продаю курсы, нужна подписка через Stars". Claude уточняет детали через User Spec, выбирает aiogram + PostgreSQL + Stripe, пишет Tech Spec и реализует. Через 2-3 часа — задеплоенный бот с документацией.',
      ),
      codeBlock(
        `> Опишите ваш проект
Телеграм-бот для продажи курсов по фотографии.
Оплата через Telegram Stars, 3 уровня подписки.

> Какая аудитория?
Русскоязычные фотографы, 500-2000 подписчиков в Telegram.

[Claude уходит в работу, фазы 0-6 автоматически...]`,
        "text",
      ),
      heading(3, "SaaS-дашборд на Next.js"),
      paragraph(
        "Для более сложных продуктов — та же схема. Claude сам предложит Payload CMS если нужен контент, PostgreSQL для данных, Docker Compose для деплоя. Пользователь одобряет архитектуру на фазе 2, потом следит за чекпоинтами.",
      ),
      codeBlock(
        `# Пример Tech Spec, который генерирует Claude:
Стек: Next.js 15, Payload CMS, PostgreSQL, Docker
Хостинг: VPS Beget, Nginx, Let's Encrypt
Авторизация: NextAuth.js, JWT httpOnly cookies
Деплой: docker compose up -d --build`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Если у вас несколько серверов — запустите `/new-project` в отдельной tmux-сессии. Каждый проект получает свой GitHub Actions runner для CI/CD. После фазы 6 деплой происходит автоматически при каждом пуше в `main`.",
      ),
      codeBlock(
        `# Запуск в tmux (рекомендуется для долгих сессий)
tmux new -s my-project
/new-project

# CI/CD после завершения (автоматически):
# push -> GitHub Actions -> SSH -> docker compose up`,
        "bash",
      ),
      quote(
        "Один вопрос в начале сессии запускает цепочку, которая раньше занимала несколько дней работы.",
      ),
    ]),
    seoTitle: "/new-project — проект от нуля до деплоя за сессию",
    seoDescription:
      "Команда /new-project: 7 фаз — VPS, User Spec, Tech Spec, декомпозиция, реализация, тесты, деплой. Полный пайплайн создания продукта.",
  },

  // ─────────────────────────────────────────────────────────
  // 2. /end
  // ─────────────────────────────────────────────────────────
  {
    slug: "end-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/end** корректно завершает рабочую сессию с сохранением всего контекста. Обновляет CLAUDE.md, коммитит незакоммиченные изменения, фиксирует на чём остановились и что делать в следующий раз. Следующая сессия начнётся с правильного места без потери контекста.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Завершение сессии
/end

# Без аргументов. Claude сам проверит:
# - незакоммиченные изменения
# - актуальность CLAUDE.md
# - статус задач в бэклоге`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Проверяет `git status` — находит незакоммиченные изменения",
          "Предлагает коммит с описательным сообщением по Conventional Commits",
          "Обновляет секцию ПРОГРЕСС в CLAUDE.md: фаза, этап, следующая задача",
          "Записывает принятые решения и контекст для следующей сессии",
          "Обновляет бэклог: помечает завершённые задачи, добавляет обнаруженный техдолг",
          "Показывает итоговую сводку: что сделано, что осталось, оценка времени",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Обычное завершение рабочего дня"),
      paragraph(
        "В конце сессии вы поняли, что устали и хотите продолжить завтра. Вызываете `/end` — Claude сохраняет всё, включая мысли о том, что нужно сделать дальше.",
      ),
      codeBlock(
        `# Пример вывода /end:
Незакоммиченные изменения: src/api/auth.ts, src/lib/jwt.ts

Предлагаю коммит:
feat: авторизация через Telegram HMAC-SHA256

Обновляю CLAUDE.md...
Следующая задача: 5.8 — страница /profile/[username]
Оценка: ~45 минут`,
        "text",
      ),
      heading(3, "Прерывание по обстоятельствам"),
      paragraph(
        'Если нужно срочно переключиться — `/end` зафиксирует состояние даже в середине задачи. В CLAUDE.md запишется "прервано на шаге X, нужно продолжить с Y".',
      ),
      codeBlock(
        `# В CLAUDE.md после /end:
**Фаза:** 5 — UGC (в процессе)
**Этап:** Прервано на 5.6 — API /api/comments
**Статус:** Написан файл, не дописан rate limiting
**Следующее:** Дописать rate limiting, потом тесты`,
        "markdown",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Хук `stop-check-progress.sh` автоматически напоминает про `/end` при завершении сессии. Если в репозитории есть незакоммиченные изменения и пользователь пытается закрыть Claude — хук предупреждает.",
      ),
      codeBlock(
        `# Хук срабатывает автоматически на Stop-событие
# В .claude/settings.json:
{
  "hooks": {
    "Stop": ["bash ~/.claude/hooks/stop-check-progress.sh"]
  }
}`,
        "json",
      ),
      quote(
        "Сессия без /end — как закрыть IDE без сохранения. Технически можно, но зачем?",
      ),
    ]),
    seoTitle: "/end — завершение сессии с сохранением прогресса",
    seoDescription:
      "Команда /end: коммит изменений, обновление CLAUDE.md, фиксация прогресса. Корректное завершение для бесшовного продолжения.",
  },

  // ─────────────────────────────────────────────────────────
  // 3. /done
  // ─────────────────────────────────────────────────────────
  {
    slug: "done-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/done** финализирует конкретную задачу — не сессию, а именно задачу. Запускает полный набор QA-проверок, записывает AI_NOTES с деталями реализации, обновляет прогресс. Это финальный аккорд каждого блока работы перед переходом к следующему.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Финализация текущей задачи
/done

# Применяется к текущей активной задаче.
# Claude определяет её из секции ПРОГРЕСС в CLAUDE.md.`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Определяет текущую активную задачу из CLAUDE.md",
          "Запускает QA-проверки: тесты, lint, typecheck, anti-mirage check",
          "Записывает AI_NOTES в `docs/ai-notes/block-N.md`: решения, компромиссы, техдолг",
          "Фиксирует cost-tracker: токены, время, стоимость сессии",
          "Обновляет архитектурную документацию если были структурные изменения",
          "Помечает задачу как завершённую в CLAUDE.md и бэклоге",
          "Предлагает переход к следующей задаче",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "После реализации API-эндпоинта"),
      paragraph(
        "Написали `/api/reactions` — 150 строк кода с дедупликацией по fingerprint. Вызываете `/done`, Claude проверяет что ничего не сломано и записывает детали.",
      ),
      codeBlock(
        `# AI_NOTES после /done:
## Задача 5.5: API /api/reactions

### Решения:
- Дедупликация по fingerprint (IP + User-Agent hash)
- Rate limit: 10 реакций/мин на fingerprint
- Хранение в PostgreSQL, не Redis (упрощение)

### Техдолг:
- Fingerprint слабый, нужен canvas fingerprint позже
- Нет инвалидации кэша при смене реакции`,
        "markdown",
      ),
      heading(3, "После блока из нескольких файлов"),
      paragraph(
        "Блок 7 включал 5 файлов: FeedCard, FeedFilters, InfiniteScroll, Sidebar, данные. После завершения блока `/done` сканирует все изменения и пишет единый AI_NOTES.",
      ),
      codeBlock(
        `# Пример вывода:
QA-проверки:
  tsc --noEmit        OK (0 ошибок)
  eslint              OK (0 предупреждений)
  jest --coverage     OK (84% покрытие)
  anti-mirage check   OK (все импорты существуют)

AI_NOTES записаны: docs/ai-notes/block-7.md
Cost: ~$0.18 | Время: 42 мин | Токены: 45k`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В связке с `/ship`: после каждого блока реализации `/ship` автоматически вызывает `/done`. Вы видите результат чекпоинта и решаете — продолжать или скорректировать курс.",
      ),
      codeBlock(
        `# /done vs /end — разница:
/done  → финализация ЗАДАЧИ  (с QA, AI_NOTES)
/end   → завершение СЕССИИ   (с коммитом, обновлением CLAUDE.md)

# Типичный паттерн:
реализация блока → /done → [следующий блок] → ... → /end`,
        "bash",
      ),
      quote(
        "AI_NOTES — это память между сессиями. Без них каждая сессия начинается с амнезии.",
      ),
    ]),
    seoTitle: "/done — финализация задачи с QA-проверками",
    seoDescription:
      "Команда /done: QA-проверки, AI_NOTES, cost-tracker, обновление прогресса. Финализация задачи перед переходом к следующей.",
  },

  // ─────────────────────────────────────────────────────────
  // 4. /code-review
  // ─────────────────────────────────────────────────────────
  {
    slug: "code-review-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/code-review** запускает субагента code-reviewer для анализа написанного кода. Проверяет соблюдение стандартов DRY, KISS, YAGNI, находит потенциальные уязвимости, указывает на проблемы именования и нарушения ограничений по размеру. Каждая находка классифицируется по severity.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Ревью staged изменений (по умолчанию)
/code-review

# Ревью конкретного файла
/code-review src/api/auth.ts

# Ревью директории
/code-review src/services/`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Определяет область ревью: staged изменения или указанный путь",
          "Анализирует структуру: размеры функций и файлов",
          "Проверяет DRY: ищет дублирование логики",
          "Проверяет безопасность: хардкод секретов, SQL-инъекции, XSS",
          "Анализирует именование: понятны ли переменные и функции без контекста",
          "Классифицирует каждую находку: Critical / Major / Minor",
          "Предлагает конкретные исправления, не абстрактные рекомендации",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Ревью перед коммитом"),
      paragraph(
        "Написали обработчик авторизации — хотите убедиться, что нет очевидных проблем. Запускаете `/code-review` и получаете структурированный отчёт.",
      ),
      codeBlock(
        `# Пример вывода /code-review:
Файл: src/api/auth/telegram.ts (87 строк)

[Critical] Строка 34: TELEGRAM_BOT_TOKEN хардкодирован в коде
  → Перенести в process.env.TELEGRAM_BOT_TOKEN

[Major] Строка 45-67: функция verifyHmac() — 22 строки, окей
[Major] Строка 12: нет rate limiting на эндпоинт
  → Добавить middleware rateLimit({ max: 10, windowMs: 60000 })

[Minor] Строки 78-82: дублирование с lib/telegram.ts:45
  → Вынести в shared утилиту`,
        "text",
      ),
      heading(3, "Ревью большого блока изменений"),
      paragraph(
        "После реализации целой фичи из 5 файлов — запускаете ревью директории. Claude анализирует каждый файл и даёт общую картину.",
      ),
      codeBlock(
        `# Ревью директории
/code-review src/components/feed/

# Результат: 12 файлов, 847 строк
# Critical: 0
# Major: 3 (дублирование в FeedCard/FeedFilters)
# Minor: 7 (именование, комментарии)`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В рамках Quality Gate 2 ревью запускается автоматически после написания кода >10 строк. Для security-sensitive кода (авторизация, платежи) дополнительно подключается security-reviewer. Результаты записываются в AI_NOTES молча — без отвлечения пользователя.",
      ),
      codeBlock(
        `# Интеграция в /ship:
Phase 4 (Build) → пишем код
  ↓ автоматически
Gate 2 → /code-review
  ↓ если есть Critical
Auto-Fix → исправляем
  ↓
Показываем пользователю финальный код`,
        "text",
      ),
      quote(
        "Код-ревью от человека — редкость в соло-разработке. AI-агент делает это после каждого блока.",
      ),
    ]),
    seoTitle: "/code-review — ревью кода через AI-агента",
    seoDescription:
      "Команда /code-review: DRY, KISS, безопасность, именование, размеры. Структурированный ревью с severity Critical/Major/Minor.",
  },

  // ─────────────────────────────────────────────────────────
  // 5. /tdd
  // ─────────────────────────────────────────────────────────
  {
    slug: "tdd-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/tdd** ведёт через полный RED-GREEN-REFACTOR цикл. Сначала пишутся тесты, которые должны падать. Потом — минимальный код для их прохождения. Потом — рефакторинг без потери зелёных тестов. Каждый шаг валидируется автоматическим запуском тест-раннера.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# TDD для конкретной задачи
/tdd добавить валидацию email при регистрации

# Без аргументов — Claude спросит описание
/tdd`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "**RED**: Claude пишет тесты для описанной функциональности — они должны падать",
          "Автоматический запуск тестов, проверка что они действительно падают (не из-за синтаксиса)",
          "**GREEN**: минимальный код для прохождения тестов — буквально минимальный",
          "Автоматический запуск тестов, все должны пройти",
          "**REFACTOR**: улучшение кода без изменения поведения",
          "Финальный запуск — все тесты зелёные, код чище",
          "Итерация для следующего сценария или edge-case",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Валидация пользовательского ввода"),
      paragraph(
        "Нужна функция проверки email. Через TDD сначала описываем все случаи, потом реализуем — уверены что ничего не пропустили.",
      ),
      codeBlock(
        `// RED — тесты написаны первыми:
describe('validateEmail', () => {
  it('принимает корректный email', () => {
    expect(validateEmail('user@example.com')).toBe(true)
  })
  it('отклоняет без @', () => {
    expect(validateEmail('userexample.com')).toBe(false)
  })
  it('отклоняет пустую строку', () => {
    expect(validateEmail('')).toBe(false)
  })
  it('отклоняет null', () => {
    expect(validateEmail(null)).toBe(false)
  })
})

// [Тесты запущены — все падают. GREEN идёт...]

// GREEN — минимальная реализация:
function validateEmail(email: unknown): boolean {
  if (!email || typeof email !== 'string') return false
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}`,
        "typescript",
      ),
      heading(3, "Бизнес-логика с edge-cases"),
      paragraph(
        "TDD особенно ценен для расчётов и бизнес-правил. Тесты описывают ожидания — Claude реализует функцию, которая точно им соответствует.",
      ),
      codeBlock(
        `// Расчёт скидки: сложная логика с условиями
/tdd функция расчёта скидки:
  - 5% при заказе > 1000 руб
  - 10% при заказе > 5000 руб
  - 15% для premium-пользователей (любая сумма)
  - нельзя применять две скидки одновременно`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Автоопределение тест-раннера по конфигам проекта: `jest.config.*`, `vitest.config.*`, `pytest.ini`, `pyproject.toml`. Не нужно указывать какой инструмент использовать — Claude найдёт сам.",
      ),
      codeBlock(
        `# Поддерживаемые тест-раннеры:
Jest        → jest --watch (TypeScript/JavaScript)
Vitest      → vitest (Vite-проекты)
pytest      → pytest -v (Python)
Go test     → go test ./... (Go)

# /tdd в CI не запускать — только локально`,
        "bash",
      ),
      quote(
        "Тесты — не обуза, а навигатор. Они говорят что делать дальше и сигнализируют когда что-то сломалось.",
      ),
    ]),
    seoTitle: "/tdd — TDD-цикл RED-GREEN-REFACTOR через агента",
    seoDescription:
      "Команда /tdd: пишем тесты, запускаем (RED), реализуем (GREEN), рефакторим. Пошаговый TDD с автоматическим тест-раннером.",
  },

  // ─────────────────────────────────────────────────────────
  // 6. /test
  // ─────────────────────────────────────────────────────────
  {
    slug: "test-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/test** запускает тесты проекта, анализирует результаты и даёт конкретные рекомендации. Автоматически определяет тест-раннер по конфигам проекта, показывает coverage по файлам, разбирает падения с предложениями исправления. Это не просто `npm test` — это анализ.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Запуск всех тестов
/test

# Конкретный файл или директория
/test src/api/auth.test.ts
/test src/services/

# Только coverage (без запуска)
/test --coverage-only`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Находит конфиги: `jest.config.*`, `vitest.config.*`, `pytest.ini` — определяет тест-раннер",
          "Запускает тесты с coverage флагом",
          "Анализирует результаты: прошедшие / упавшие / пропущенные",
          "Для каждого упавшего теста: объясняет причину на понятном языке",
          "Проверяет coverage: какие файлы ниже 80% порога",
          "Даёт конкретные рекомендации: что написать, какие edge-cases добавить",
          "Показывает сводку: X прошло, Y упало, покрытие Z%",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Анализ падения после рефакторинга"),
      paragraph(
        "Переименовали функцию — тесты упали. `/test` покажет точно какие тесты и почему, не заставит читать километры jest-вывода.",
      ),
      codeBlock(
        `# Пример вывода /test:
Тест-раннер: Jest 29.7
Запущено: 47 тестов в 12 файлах

ПРОШЛО: 44
УПАЛО:   3
  ✗ auth.test.ts:34 — validateToken не определена
    Причина: функция переименована в verifyToken (src/lib/jwt.ts:12)
    Исправление: заменить validateToken → verifyToken в тесте

  ✗ reactions.test.ts:67 — timeout 5000ms
    Причина: мок не настроен для нового параметра fingerprint
    Исправление: добавить fingerprint: 'test-hash' в фикстуру

Coverage: 76% (ниже порога 80%)
Файлы без покрытия: src/lib/telegram.ts (0%), src/utils/date.ts (45%)`,
        "text",
      ),
      heading(3, "Проверка перед деплоем"),
      paragraph(
        "Перед пушем в прод — запускаете `/test` для уверенности. Если всё зелёное — продолжаете, если нет — Claude сразу указывает что чинить.",
      ),
      codeBlock(
        `# Интеграция в workflow:
/test                  # запуск + анализ
  ↓ если 0 падений
/pre-commit-check      # финальные проверки
  ↓
git commit + git push`,
        "bash",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В Quality Gate 2 тесты запускаются автоматически после написания кода. В `/done` — финальный прогон. В CI через GitHub Actions — при каждом пуше в `main`. Если тесты упали в CI — Auto-Fix Pipeline пытается исправить до 3 раз.",
      ),
      codeBlock(
        "# GitHub Actions конфиг (автоматически генерирует /new-project):\n- name: Тесты\n  run: npm test -- --coverage --ci\n  env:\n    NODE_ENV: test\n    DATABASE_URL: \${{ secrets.TEST_DATABASE_URL }}",
        "yaml",
      ),
      quote(
        "Разница между /tdd и /test: /tdd ведёт через написание тестов, /test запускает и анализирует уже написанные.",
      ),
    ]),
    seoTitle: "/test — запуск тестов с анализом падений и coverage",
    seoDescription:
      "Команда /test: автоопределение тест-раннера, анализ падений, coverage по файлам. Не просто npm test — разбор результатов.",
  },

  // ─────────────────────────────────────────────────────────
  // 7. /deploy
  // ─────────────────────────────────────────────────────────
  {
    slug: "deploy-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/deploy** выполняет полный цикл деплоя на VPS через Docker: сборка образа, проверка env vars, `docker compose up -d --build`, health check. При ошибке — Auto-Fix Pipeline с 3 попытками и откатом на предыдущую версию. Подключается к серверу через MCP SSH.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Деплой на production (по умолчанию)
/deploy

# Деплой на staging
/deploy --env staging

# Принудительная пересборка без кэша
/deploy --force

# Dry run — показать что будет делать
/deploy --dry-run`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Проверяет что все изменения закоммичены (нет dirty working tree)",
          "Подключается к VPS через MCP SSH-сервер",
          "Проверяет наличие всех env vars из `.env.example` на сервере",
          "Запускает `docker compose build --no-cache` (или с кэшем без `--force`)",
          "Выполняет `docker compose up -d` — старый контейнер меняется без даунтайма",
          "Health check: проверяет `/api/health` или настроенный endpoint",
          "При успехе — уведомление с новой версией; при ошибке — Auto-Fix Pipeline",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Стандартный деплой фичи"),
      paragraph(
        "Закончили разработку, тесты прошли, хотите выкатить на прод. Вызываете `/deploy` — Claude делает всё сам, включая проверку что ничего не забыли.",
      ),
      codeBlock(
        `# Пример вывода /deploy:
Подключение: stackovervibe (109.172.36.108)
Git: ветка main, коммит c645f54

Проверка env vars:
  PAYLOAD_SECRET      OK
  DATABASE_URI        OK
  NEXT_PUBLIC_URL     OK
  TELEGRAM_BOT_TOKEN  OK

Docker build... (2m 34s)
docker compose up -d --build

Health check: https://stackovervibe.ru/api/health
Status: 200 OK

Деплой успешен. Версия: c645f54`,
        "text",
      ),
      heading(3, "Деплой с откатом при ошибке"),
      paragraph(
        "Если health check упал — Auto-Fix Pipeline пробует исправить. Если 3 попытки провалились — автоматический откат на предыдущий рабочий образ.",
      ),
      codeBlock(
        `# Auto-Fix Pipeline при ошибке деплоя:
Попытка 1: Health check упал — читаю логи
  → Ошибка: DATABASE_URI некорректный
  → Исправляю env на сервере

Попытка 2: Health check прошёл
  → Деплой успешен

# Если все 3 попытки провалились:
git revert HEAD && git push
→ автоматический откат к предыдущей версии`,
        "bash",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В CI/CD: каждый пуш в `main` запускает GitHub Actions, который через self-hosted runner выполняет SSH-деплой. Ручной `/deploy` нужен только для срочных хотфиксов или деплоя без пуша.",
      ),
      codeBlock(
        `# CI/CD pipeline (GitHub Actions):
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: self-hosted  # runner на secondbrain
    steps:
      - name: Deploy
        run: |
          ssh stackovervibe "cd /home/claude/stackovervibe &&
            git pull &&
            docker compose up -d --build"`,
        "yaml",
      ),
      quote(
        "Хороший деплой — тот, о котором не думаешь. /deploy + CI/CD делают выкладку скучной рутиной.",
      ),
    ]),
    seoTitle: "/deploy — деплой на VPS через Docker с rollback",
    seoDescription:
      "Команда /deploy: Docker build, docker compose, health check, Auto-Fix Pipeline, rollback. Полный цикл деплоя на VPS.",
  },

  // ─────────────────────────────────────────────────────────
  // 8. /ship
  // ─────────────────────────────────────────────────────────
  {
    slug: "ship-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/ship** проводит фичу через полный цикл разработки: brainstorm, планирование, одобрение пользователем, реализация с чекпоинтами, тесты, код-ревью, коммит. Оптимален для задач уровня Feature (15-60 минут). Координирует 3-5 субагентов через Team Lead.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Ship с описанием фичи
/ship добавить систему реакций (лайк/дизлайк) на посты

# Без аргументов — Claude спросит
/ship`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "**Brainstorm**: анализирует задачу, задаёт уточняющие вопросы, выявляет edge-cases",
          "**Plan**: декомпозиция на блоки, оценка времени, список файлов для изменения",
          "**Approve**: показывает план пользователю — ждёт одобрения или правок",
          "**Build**: реализация блок за блоком, чекпоинт после каждого",
          "**Test**: тесты для каждого блока, `/test` на финале",
          "**Review**: автоматический `/code-review` staged изменений",
          "**Commit**: Conventional Commits формат, `/done` для финализации",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Система реакций для постов"),
      paragraph(
        "Классическая Feature-задача: нужно добавить лайки/дизлайки. `/ship` разберётся с дедупликацией, хранением, API и фронтендом.",
      ),
      codeBlock(
        `/ship добавить реакции (лайк/дизлайк) на вопросы и посты

# Claude задаст уточнения:
# — Аноним может реагировать? Нет, только авторизованные
# — Хранить историю? Нет, только текущая реакция
# — Real-time обновление? Нет, при перезагрузке

# Plan (ждёт одобрения):
Блок 1: API /api/reactions (GET, POST) — 20 мин
Блок 2: Компонент ReactionButtons — 15 мин
Блок 3: Интеграция в PostCard — 10 мин
Блок 4: Тесты — 15 мин

[Одобряете план?]`,
        "text",
      ),
      heading(3, "Страница профиля пользователя"),
      paragraph(
        "Более комплексная задача с несколькими компонентами. `/ship` сам определяет что реализовывать параллельно, что последовательно.",
      ),
      codeBlock(
        `/ship страница /profile/[username] с постами и статистикой

# После одобрения плана:
--- ЧЕКПОИНТ: Блок 1 завершён ---
Сделано: API /api/profile/[username]
Следующий: Блок 2 — компонент ProfileHeader
Продолжаем? [да/нет/скорректировать]`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Внутри `/ship` автоматически работают все hooks: security-scan на каждый Edit, prettier после каждого сохранения, stop-check при завершении. `/ship` — это оркестратор, не замена инструментам.",
      ),
      codeBlock(
        `# Разница по масштабу задач:
Quick Fix  → /bug-fix  (5-15 мин, 1 файл)
Feature    → /ship     (15-60 мин, несколько файлов)
Epic       → ручной plan + /ship по блокам
Project    → /new-project`,
        "text",
      ),
      quote(
        "/ship — это не автопилот, а умный штурман. Вы одобряете план и чекпоинты, агент реализует.",
      ),
    ]),
    seoTitle: "/ship — полный Feature pipeline от идеи до коммита",
    seoDescription:
      "Команда /ship: brainstorm, план с одобрением, реализация по блокам, тесты, ревью, коммит. Feature за одну сессию.",
  },

  // ─────────────────────────────────────────────────────────
  // 9. /status
  // ─────────────────────────────────────────────────────────
  {
    slug: "status-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/status** показывает полный срез состояния проекта за один вызов: git (ветка, изменения, последние коммиты), Docker (контейнеры, использование CPU/памяти), последние ошибки из логов, прогресс из CLAUDE.md и количество задач в бэклоге. Идеальная стартовая команда в начале сессии.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Статус текущего проекта
/status

# Без аргументов. Анализирует CWD как проект.`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Читает секцию ПРОГРЕСС из CLAUDE.md — текущая фаза, этап, следующая задача",
          "Выполняет `git status` — незакоммиченные изменения, текущая ветка",
          "Выполняет `git log --oneline -5` — последние коммиты",
          "Выполняет `docker compose ps` — статус контейнеров",
          "Читает `docker logs --tail 20` — последние строки логов, ищет ERROR",
          "Читает бэклог из `docs/tasks.md` — сколько задач в очереди",
          "Показывает сводный дашборд в читаемом формате",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Начало новой сессии"),
      paragraph(
        "Прошло несколько дней, нужно вспомнить где остановились. Вместо чтения CLAUDE.md — один вызов `/status`.",
      ),
      codeBlock(
        `# Пример вывода /status:
=== ПРОГРЕСС ===
Фаза: 9 — Frameworks UGC-каталог
Следующее: Деплой (git push → CI → prod)

=== GIT ===
Ветка: main (ahead of origin/main by 3 commits)
Незакоммиченное: нет

=== DOCKER ===
app       Up 2 days    (0.3% CPU, 312MB RAM)
postgres  Up 2 days    (0.1% CPU, 87MB RAM)

=== ЛОГИ (последние ошибки) ===
[warn] 2026-02-27 14:23 — медленный запрос (230ms): /api/feed

=== БЭКЛОГ ===
В очереди: 8 задач (2 high, 6 medium)`,
        "text",
      ),
      heading(3, "Проверка после деплоя"),
      paragraph(
        "Задеплоили — хотите убедиться что всё работает. `/status` покажет статус контейнеров и последние логи без SSH.",
      ),
      codeBlock(
        `# После деплоя:
=== DOCKER ===
app       Up 3 minutes  (0.8% CPU — прогрев)
postgres  Up 5 days

=== ЛОГИ ===
[info] Server started on port 3000
[info] Connected to PostgreSQL
[info] GET / 200 (124ms)`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Хук `session-start-progress.sh` автоматически показывает краткую версию `/status` при начале сессии — только прогресс и следующую задачу. Полный `/status` — по требованию.",
      ),
      codeBlock(
        `# Хук в .claude/settings.json:
{
  "hooks": {
    "SessionStart": ["bash ~/.claude/hooks/session-start-progress.sh"]
  }
}

# Выводит при старте:
Проект: stackovervibe
Фаза: 9 | Следующее: деплой`,
        "json",
      ),
      quote(
        "Хороший статус — это не дамп информации, а навигационная точка: где я, куда идти.",
      ),
    ]),
    seoTitle: "/status — состояние проекта: git, Docker, прогресс",
    seoDescription:
      "Команда /status: git ветка, Docker контейнеры, последние логи, прогресс, бэклог. Полная картина за один вызов.",
  },

  // ─────────────────────────────────────────────────────────
  // 10. /backlog
  // ─────────────────────────────────────────────────────────
  {
    slug: "backlog-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        '**/backlog** — интерфейс к бэклогу проекта. Просмотр всех задач с приоритетами, добавление новых с классификацией, AI-приоритизация через RICE-скоринг. Ничто из "сделать потом" не теряется — всё в одном месте с оценкой важности.',
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Показать бэклог
/backlog

# Добавить задачу (Claude спросит детали)
/backlog add

# Добавить с описанием сразу
/backlog add добавить экспорт в CSV

# AI-приоритизация через RICE
/backlog prioritize`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "`/backlog` — читает `docs/tasks.md`, показывает задачи сгруппированные по приоритету",
          "`/backlog add` — запрашивает тип (feature/bug/tech-debt/idea), описание, примерный размер (S/M/L)",
          "Записывает задачу в `docs/tasks.md` с датой добавления",
          "`/backlog prioritize` — анализирует все задачи через RICE-скоринг",
          "RICE: Reach × Impact × Confidence / Effort — пересортировывает по результату",
          "Показывает топ-5 задач для следующего спринта",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Просмотр текущего бэклога"),
      paragraph(
        'В начале недели — смотрите что накопилось и что делать дальше. RICE помогает не зависнуть на "интересных" задачах вместо "важных".',
      ),
      codeBlock(
        `# Вывод /backlog:
=== CRITICAL (1) ===
[BUG] Падение при пустом avatar_url в профиле — @high

=== HIGH (3) ===
[FEATURE] Уведомления при ответе на вопрос
[FEATURE] Поиск по тексту внутри ответов
[TECH-DEBT] Оптимизация N+1 в getFeedPage

=== MEDIUM (5) ===
[FEATURE] Экспорт постов в Markdown
[IDEA] Система достижений (badges)
...`,
        "text",
      ),
      heading(3, "Добавление задачи из контекста"),
      paragraph(
        "Во время работы заметили техдолг — не отвлекаетесь, добавляете в бэклог и продолжаете. Ничего не теряется.",
      ),
      codeBlock(
        `/backlog add

Тип: tech-debt
Описание: Fingerprint в /api/reactions слабый (IP+UA),
  нужен canvas fingerprint для лучшей дедупликации
Размер: M (Feature)
Приоритет: medium

→ Добавлено в docs/tasks.md`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Бэклог — живой документ. `/end` автоматически добавляет в него техдолг найденный за сессию. `/done` помечает задачи как завершённые. Бэклог всегда актуален без ручного ведения.",
      ),
      codeBlock(
        `# RICE-формула для приоритизации:
Reach      — сколько пользователей затронет (1-10)
Impact     — насколько улучшит опыт (0.25-3)
Confidence — уверенность в оценках (50%-100%)
Effort     — дни разработки

Score = (Reach × Impact × Confidence) / Effort

# Пример:
"Поиск" — Score: (8 × 2 × 0.8) / 3 = 4.3
"Badges" — Score: (3 × 1 × 0.5) / 5 = 0.3`,
        "text",
      ),
      quote(
        "Бэклог без приоритизации — это свалка. RICE превращает свалку в очередь, в которой понятно что делать первым.",
      ),
    ]),
    seoTitle: "/backlog — управление бэклогом и RICE-приоритизация",
    seoDescription:
      "Команда /backlog: просмотр задач, добавление, RICE-скоринг. Управление бэклогом проекта через AI без потерь задач.",
  },

  // ─────────────────────────────────────────────────────────
  // 11. /docs
  // ─────────────────────────────────────────────────────────
  {
    slug: "docs-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/docs** генерирует и обновляет документацию проекта по стандарту Vibe Framework. Создаёт или обновляет 4 файла Project Knowledge, README.md, CLAUDE.md. Ключевой принцип: документация содержит только ссылки на код, не сам код. Открыл — понял проект без чтения исходников.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Обновить существующую документацию
/docs

# Генерация с нуля
/docs generate

# Аудит: найти устаревшее
/docs audit

# Обновить конкретный файл
/docs update architecture`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Читает существующую документацию, CLAUDE.md, README.md",
          "**project.md**: обзор, аудитория, проблема, ключевые фичи, scope (что не делает)",
          "**architecture.md**: стек (почему именно этот), структура, зависимости, модель данных",
          "**patterns.md**: проектные паттерны, git workflow, бизнес-правила",
          "**deployment.md**: платформа, env vars, CI/CD, rollback, мониторинг",
          "Удаляет блоки кода из документации — заменяет ссылками на файлы",
          "Помечает устаревшую информацию, проверяет что файлы из доков существуют",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "После завершения большой фичи"),
      paragraph(
        "Закончили реализацию Q&A системы — архитектура изменилась. `/docs update architecture` обновляет только нужный файл, не переписывает всё.",
      ),
      codeBlock(
        `/docs update architecture

# Claude обновит:
# - Новые коллекции: Questions, Answers
# - Новые API: /api/views, /api/feed
# - Обновлённую схему данных
# - Ссылки на новые файлы

# Не трогает: patterns.md, deployment.md`,
        "text",
      ),
      heading(3, "Аудит перед деплоем"),
      paragraph(
        "Перед крупным деплоем — проверяете что документация актуальна. `/docs audit` находит устаревшие ссылки, несуществующие файлы, плейсхолдеры.",
      ),
      codeBlock(
        `/docs audit

# Результат:
НАЙДЕНО 4 проблемы:

[Warn] architecture.md:45 — упоминает /api/analytics, эндпоинт удалён
[Warn] deployment.md:12 — порт 3001 устарел, сейчас 3000
[Info] patterns.md:78 — TODO без срока (добавить в бэклог)
[Info] project.md — нет секции "Ограничения scope"

Исправить? [да/нет]`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        'DECISIONS.md — журнал стратегических решений. Когда выбираете технологию или принимаете архитектурное решение — `/docs` предлагает записать контекст. Через полгода не нужно гадать "почему именно PostgreSQL, а не MongoDB".',
      ),
      codeBlock(
        `# Формат DECISIONS.md (генерирует /docs):
## [2026-02-15] Выбор Lexical вместо Slate

**Контекст:** Нужен богатый редактор для UGC-контента
**Решение:** Lexical (Meta) — лучшая интеграция с Payload CMS
**Альтернативы:** Slate (сложный API), TipTap (платные фичи)
**Последствия:** Lexical API нестабилен между минорами`,
        "markdown",
      ),
      quote(
        "Документация без кода — это то, что можно читать через год и всё ещё понимать. Код устаревает, решения — нет.",
      ),
    ]),
    seoTitle: "/docs — генерация Project Knowledge и документации",
    seoDescription:
      "Команда /docs: Project Knowledge (4 файла), CLAUDE.md, README, DECISIONS.md. Документация по стандарту Vibe Framework.",
  },

  // ─────────────────────────────────────────────────────────
  // 12. /migrate
  // ─────────────────────────────────────────────────────────
  {
    slug: "migrate-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/migrate** управляет миграциями базы данных: создаёт, проверяет rollback, применяет на dev или prod. Автоматически определяет систему миграций по проекту (Alembic, Prisma Migrate, Django). Перед любым деструктивным изменением (DROP) — предупреждает и создаёт бэкап.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Создать новую миграцию
/migrate create добавить индекс на questions.slug

# Применить все ожидающие миграции
/migrate apply

# Откатить последнюю миграцию
/migrate rollback

# Показать текущее состояние
/migrate status`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Определяет систему миграций: ищет `alembic.ini`, `prisma/schema.prisma`, `manage.py`",
          "Проверяет текущее состояние: нет ли незаappлицированных миграций",
          "`create`: генерирует новую миграцию с описательным именем (дата + описание)",
          "Автоматически проверяет rollback: `downgrade -1` → `upgrade head` на dev-базе",
          "`apply`: применяет миграции с бэкапом если есть деструктивные операции",
          "При DROP TABLE/COLUMN — явное предупреждение и запрос подтверждения",
          "На prod: создаёт `pg_dump` бэкап перед применением",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Добавление новой таблицы"),
      paragraph(
        "Разрабатываете фичу Frameworks — нужна новая коллекция. `/migrate create` генерирует миграцию и проверяет что rollback работает.",
      ),
      codeBlock(
        `/migrate create добавить коллекцию frameworks

# Создана миграция:
# 20260227_182730_добавить_коллекцию_frameworks.ts

# Автопроверка rollback:
prisma migrate dev --name добавить_коллекцию_frameworks
prisma migrate reset --force  # тест rollback на dev
prisma migrate dev            # применить снова

# Результат: rollback работает, безопасно деплоить`,
        "bash",
      ),
      heading(3, "Деструктивная миграция (удаление поля)"),
      paragraph(
        "Удаляете deprecated поле. `/migrate` предупреждает и создаёт бэкап перед применением на проде.",
      ),
      codeBlock(
        `/migrate create удалить поле legacy_username из users

# Предупреждение:
[WARN] Деструктивная операция: DROP COLUMN users.legacy_username
  Данные будут удалены безвозвратно.

  Проверьте что код не использует это поле:
  grep -r "legacy_username" src/  → 0 результатов

  Создать бэкап таблицы users перед применением?
  [да/нет]

# После подтверждения:
pg_dump -t users > backup_users_20260227.sql
Миграция применена.`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В CI/CD миграции применяются автоматически при деплое. Порядок: сначала миграция, потом перезапуск приложения. Если миграция упала — деплой останавливается, rollback применяется автоматически.",
      ),
      codeBlock(
        `# Порядок деплоя в docker-compose.yml:
services:
  migrate:
    image: app
    command: npx payload migrate
    depends_on:
      postgres:
        condition: service_healthy

  app:
    image: app
    depends_on:
      migrate:
        condition: service_completed_successfully`,
        "yaml",
      ),
      quote(
        "Миграция без проверки rollback — это мина замедленного действия. /migrate проверяет это за вас.",
      ),
    ]),
    seoTitle: "/migrate — миграции БД: Prisma, Alembic, rollback",
    seoDescription:
      "Команда /migrate: создание, проверка rollback, применение с бэкапом. Безопасные миграции для Prisma, Alembic, Django.",
  },

  // ─────────────────────────────────────────────────────────
  // 13. /cleanup
  // ─────────────────────────────────────────────────────────
  {
    slug: "cleanup-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/cleanup** ищет и удаляет отладочный и мёртвый код: `console.log`, `debugger`, `print()`, закомментированные блоки, неиспользуемые импорты. Показывает что нашёл перед удалением и спрашивает подтверждение. Не трогает легитимные `console.error` и `console.warn`.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Чистка всего проекта
/cleanup

# Чистка конкретного файла
/cleanup src/api/auth.ts

# Чистка директории
/cleanup src/components/`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Сканирует указанный путь (или весь проект) рекурсивно",
          "Находит `console.log`, `console.debug` (JS/TS) и `print()`, `breakpoint()` (Python)",
          "Находит закомментированные блоки кода (3+ строки подряд)",
          "Находит неиспользуемые импорты через eslint-plugin-unused-imports",
          "Находит `TODO`/`FIXME` без привязки к бэклогу (предлагает добавить)",
          "Показывает полный список находок с контекстом (строка, файл)",
          "После подтверждения — удаляет, запускает prettier на изменённых файлах",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Чистка перед коммитом"),
      paragraph(
        "Отладили баг, оставили несколько `console.log`. Перед коммитом — `/cleanup` находит всё за секунды.",
      ),
      codeBlock(
        `/cleanup

Найдено 7 проблем:

src/api/reactions.ts:45    console.log('reaction data:', data)
src/api/reactions.ts:67    console.log('fingerprint:', fp)
src/components/FeedCard.tsx:23  // console.debug('render', props)
src/lib/jwt.ts:12          // старая реализация verify
src/lib/jwt.ts:13          // const decoded = jwt.verify(token, SECRET)
src/lib/jwt.ts:14          // return decoded

Не трогаю:
src/lib/logger.ts:8    console.error('DB connection failed:', err)
src/lib/logger.ts:15   console.warn('Rate limit approaching')

Удалить найденное? [да/нет]`,
        "text",
      ),
      heading(3, "Чистка после рефакторинга"),
      paragraph(
        "После крупного рефакторинга остаётся мусор: старые импорты, закомментированные блоки. `/cleanup src/` делает полный проход по директории.",
      ),
      codeBlock(
        `/cleanup src/

Найдено 12 неиспользуемых импортов:
  src/components/Header.tsx — import { useState } from 'react' (не используется)
  src/pages/index.tsx — import AnimatedContent from './AnimatedContent' (удалён)
  ...

Найдено 3 закомментированных блока (>3 строк):
  src/seed/index.ts:45-52
  ...

Удалить? [да/нет]`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Хук `stop-check-debug.sh` автоматически сканирует staged файлы при завершении сессии. Если находит `console.log` или `debugger` — предупреждает. Полный `/cleanup` запускается вручную или как часть `/pre-commit-check`.",
      ),
      codeBlock(
        `# Хук автоматически проверяет staged файлы:
# .claude/hooks/stop-check-debug.sh
git diff --staged --name-only | xargs grep -l "console\.log\|debugger"

# Если найдено:
[WARN] Debug-код в staged файлах:
  src/api/auth.ts — console.log на строке 45
  Запустите /cleanup перед коммитом`,
        "bash",
      ),
      quote(
        "console.log в production — это не просто шум в логах. Это утечка внутренней информации.",
      ),
    ]),
    seoTitle: "/cleanup — удаление console.log и мёртвого кода",
    seoDescription:
      "Команда /cleanup: console.log, debugger, print(), закомментированный код, неиспользуемые импорты. Чистка с подтверждением.",
  },

  // ─────────────────────────────────────────────────────────
  // 14. /bug-fix
  // ─────────────────────────────────────────────────────────
  {
    slug: "bug-fix-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/bug-fix** переключает Claude в Quick Fix mode: без brainstorm и планирования — сразу к анализу и исправлению. Оптимален для задач на 5-15 минут. Читает логи, локализует проблему, вносит минимальное изменение, пишет тест, коммитит с `fix:` префиксом.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# С описанием бага
/bug-fix при открытии /profile падает TypeError

# С ошибкой из логов
/bug-fix TypeError: Cannot read properties of undefined (reading 'avatar')

# Без аргументов — Claude спросит
/bug-fix`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Принимает описание бага, ошибку из логов или ссылку на issue",
          "Читает стектрейс — определяет файл и строку",
          "Анализирует контекст вокруг проблемы (соседние файлы, зависимости)",
          "Выдвигает гипотезу и проверяет её через grep по кодовой базе",
          "Вносит минимальное изменение — только то, что нужно для фикса",
          "Пишет тест который воспроизводит баг и проверяет исправление",
          "Коммитит: `fix: описание проблемы` по Conventional Commits",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "TypeError из логов"),
      paragraph(
        "Пользователь пожаловался что профиль падает. Берёте ошибку из логов и вставляете в `/bug-fix`.",
      ),
      codeBlock(
        `/bug-fix TypeError: Cannot read properties of undefined (reading 'avatar')
  at ProfileHeader (src/components/ProfileHeader.tsx:34)

# Claude анализирует:
Проблема: user.avatar может быть undefined если не загружен
Строка: <img src={user.avatar.url} />  ← нет проверки

Исправление (минимальное):
<img src={user.avatar?.url ?? '/default-avatar.png'} />

# Тест:
it('не падает при undefined avatar', () => {
  render(<ProfileHeader user={{ ...mockUser, avatar: undefined }} />)
  expect(screen.getByRole('img')).toHaveAttribute('src', '/default-avatar.png')
})

# Коммит: fix: ProfileHeader не падает при отсутствии avatar`,
        "typescript",
      ),
      heading(3, "Баг с воспроизведением"),
      paragraph(
        "Знаете шаги воспроизведения но не знаете причину. Claude ищет по кодовой базе где это может происходить.",
      ),
      codeBlock(
        `/bug-fix при фильтрации ленты по тегу "docker" — бесконечный спиннер

# Claude:
Grep: "docker" в контексте фильтров...
Найдено: getFeedPage() не сбрасывает offset при смене тега
Строка 67: offset не обнуляется при изменении filterTag

Исправление:
useEffect(() => {
  setOffset(0)    // добавить эту строку
  setItems([])
}, [filterTag])`,
        "typescript",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Если коммит с `fix:` прошёл — CI запускается автоматически. Auto-Fix Pipeline уровня 3: если CI упало — Claude читает логи и делает ещё один фикс-коммит. Максимум 3 попытки, потом `git revert`.",
      ),
      codeBlock(
        `# Auto-Fix Pipeline для /bug-fix:
/bug-fix → фикс → git commit → git push
  ↓
CI упало → читаем логи → fix-коммит #2
  ↓
CI прошло → деплой автоматически
  ↓
CI снова упало → fix-коммит #3
  ↓
CI снова упало → git revert, сообщаем пользователю`,
        "bash",
      ),
      quote(
        'Quick Fix — это не "быстрее написал, быстрее пожалеешь". Это минимальное изменение с максимальной уверенностью.',
      ),
    ]),
    seoTitle: "/bug-fix — быстрое исправление бага за 5-15 минут",
    seoDescription:
      "Команда /bug-fix: Quick Fix mode — анализ лога, минимальный фикс, тест, коммит. Без brainstorm и планирования.",
  },

  // ─────────────────────────────────────────────────────────
  // 15. /autoformat
  // ─────────────────────────────────────────────────────────
  {
    slug: "autoformat-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/autoformat** запускает форматирование кода на весь проект или конкретные файлы. Prettier для JavaScript/TypeScript, ruff для Python. Использует конфиги проекта (`.prettierrc`, `pyproject.toml`). Показывает сколько файлов изменено и что именно исправлено.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Форматировать весь проект
/autoformat

# Конкретный файл
/autoformat src/api/auth.ts

# Директория
/autoformat src/components/

# Только проверка без изменений (dry-run)
/autoformat --check`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Определяет язык по расширениям файлов в указанном пути",
          "Для JS/TS: находит `.prettierrc` или `prettier` в `package.json`, запускает `npx prettier --write`",
          "Для Python: находит `pyproject.toml` с `[tool.ruff]`, запускает `ruff format .` и `ruff check --fix .`",
          "Для смешанных проектов — запускает оба инструмента",
          "Показывает список изменённых файлов с количеством строк",
          'Если изменений нет — "всё уже отформатировано"',
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "После вставки кода из ChatGPT"),
      paragraph(
        "Вставили большой блок кода с другим стилем кавычек и отступами. Вместо ручного исправления — `/autoformat` приводит всё к единому стилю.",
      ),
      codeBlock(
        `/autoformat src/lib/telegram.ts

# Вывод:
Prettier 3.2.5
Форматирование src/lib/telegram.ts...

  Изменено: 34 → 31 строка (удалены лишние пробелы)
  Кавычки: двойные → одинарные (по .prettierrc)
  Trailing comma: добавлены в 8 местах

1 файл отформатирован.`,
        "bash",
      ),
      heading(3, "Форматирование всего проекта перед деплоем"),
      paragraph(
        "Перед крупным деплоем убеждаетесь что весь код имеет одинаковый стиль. Особенно важно если работали несколько сессий.",
      ),
      codeBlock(
        `/autoformat

# Вывод:
Prettier 3.2.5 (TypeScript/JavaScript)

Изменено файлов: 12 из 89
  src/components/FeedCard.tsx
  src/api/feed/route.ts
  src/seed/data/tools-commands.ts
  ... (ещё 9 файлов)

Без изменений: 77 файлов`,
        "bash",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Хук `post-edit-format.sh` запускает prettier автоматически после каждого Edit или Write. `/autoformat` нужен для случаев вне Edit-хука: вставка больших блоков, исправление накопившегося, форматирование перед деплоем.",
      ),
      codeBlock(
        `# Хук срабатывает автоматически:
PostToolUse (Edit/Write) → prettier/black на изменённый файл

# /autoformat нужен когда:
- вставили большой блок кода снаружи
- форматирование накопилось за несколько сессий
- хотите проверить что всё чисто перед PR

# .prettierrc пример:
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all"
}`,
        "json",
      ),
      quote(
        "Форматирование — это не стиль. Это отсутствие шума в git diff при код-ревью.",
      ),
    ]),
    seoTitle: "/autoformat — Prettier и ruff для всего проекта",
    seoDescription:
      "Команда /autoformat: Prettier для JS/TS, ruff для Python. Форматирование проекта по конфигам, показывает изменённые файлы.",
  },

  // ─────────────────────────────────────────────────────────
  // 16. /pre-commit-check
  // ─────────────────────────────────────────────────────────
  {
    slug: "pre-commit-check-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        '**/pre-commit-check** запускает полный набор проверок staged изменений перед коммитом: security scan, lint, typecheck, поиск debug-кода, проверка форматирования. Одна команда заменяет пять. Результат: "готово к коммиту" или структурированный список проблем с severity.',
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Проверка staged изменений
/pre-commit-check

# Без аргументов. Анализирует git diff --staged.`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Получает список staged файлов через `git diff --staged --name-only`",
          "**Security**: grep по паттернам (`API_KEY=`, `sk-`, `ghp_`, `PASSWORD=`, хардкод секретов)",
          "**Lint**: ESLint (JS/TS) или ruff check (Python) — только на staged файлы",
          "**Typecheck**: `tsc --noEmit` или `pyright` — только на staged файлы",
          "**Debug-код**: `console.log`, `debugger`, `print()`, `breakpoint()`",
          "**Format**: prettier --check — без изменений, только проверка",
          "Показывает итог: готово / список проблем с Critical/Major/Minor",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Чистый результат"),
      paragraph(
        'Написали фичу аккуратно — все проверки проходят. Видите чёткое "готово к коммиту".',
      ),
      codeBlock(
        `/pre-commit-check

Staged файлов: 4
  src/api/frameworks/route.ts
  src/app/framework/page.tsx
  src/lib/data.ts
  src/types/index.ts

Security scan    OK — секретов не найдено
ESLint           OK — 0 ошибок, 0 предупреждений
TypeScript       OK — 0 ошибок типов
Debug-код        OK — console.log не найдено
Форматирование   OK — всё отформатировано

Готово к коммиту.`,
        "text",
      ),
      heading(3, "Проблемы найдены"),
      paragraph(
        "Второпях оставили `console.log` и один тип с `any`. `/pre-commit-check` покажет точно что нужно исправить.",
      ),
      codeBlock(
        `/pre-commit-check

Security scan    OK
ESLint           OK

TypeScript       FAIL
  [Major] src/api/frameworks/route.ts:67
    Argument of type 'any' not assignable to 'FrameworkData'
    → заменить any на правильный тип

Debug-код        WARN
  [Minor] src/lib/data.ts:34
    console.log('frameworks:', result)
    → удалить или /cleanup

Форматирование   OK

Не готово к коммиту. Исправьте Critical/Major.`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "Integrate в git pre-commit hook — тогда проверки запускаются автоматически при каждом `git commit`. Если что-то нашлось — коммит блокируется до исправления.",
      ),
      codeBlock(
        `# .git/hooks/pre-commit (установка):
#!/bin/sh
# Запуск через Claude Code hooks (альтернатива):
# .claude/settings.json:
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": ["bash ~/.claude/hooks/pre-commit-check.sh"]
    }]
  }
}

# Хук проверяет git commit команды
# и запускает security scan автоматически`,
        "json",
      ),
      quote(
        "Проверка перед коммитом — это фильтр. В репозиторий попадает только то, что точно нормально.",
      ),
    ]),
    seoTitle: "/pre-commit-check — security, lint, типы перед коммитом",
    seoDescription:
      "Команда /pre-commit-check: security scan, ESLint, TypeScript, debug-код, форматирование. Один вызов вместо пяти проверок.",
  },

  // ─────────────────────────────────────────────────────────
  // 17. /typecheck
  // ─────────────────────────────────────────────────────────
  {
    slug: "typecheck-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/typecheck** запускает строгую проверку типов для проекта: `tsc --noEmit` для TypeScript, `pyright` для Python. Каждую ошибку объясняет на понятном языке и предлагает конкретное исправление — не просто дампит вывод компилятора.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Проверить весь проект
/typecheck

# Конкретный файл
/typecheck src/api/auth.ts

# Директория
/typecheck src/lib/`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Находит конфиг: `tsconfig.json` (TypeScript) или `pyrightconfig.json` (Python)",
          "Запускает `tsc --noEmit` — проверка без генерации файлов",
          "Парсит вывод компилятора: файл, строка, код ошибки, сообщение",
          "Для каждой ошибки — объяснение на русском что это означает",
          "Предлагает конкретное исправление: что именно изменить",
          'Показывает итог: N ошибок в M файлах, или "типы в порядке"',
          "Опционально — исправляет простые ошибки автоматически (с подтверждением)",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Проверка после рефакторинга"),
      paragraph(
        "Переименовали интерфейс — TypeScript покажет все места где нужно обновить. `/typecheck` переводит ошибки компилятора на понятный язык.",
      ),
      codeBlock(
        `/typecheck src/

Запуск tsc --noEmit...

Найдено 3 ошибки в 2 файлах:

src/components/FeedCard.tsx:45
  TS2345: Argument of type 'FeedItem' is not assignable to parameter of type 'Post'
  Что значит: FeedCard ожидает тип Post, но передаётся FeedItem
  Исправление: изменить тип пропа на FeedItem | Post (или использовать union)

src/lib/data.ts:123
  TS2339: Property 'downloads' does not exist on type 'Question'
  Что значит: у типа Question нет поля downloads, оно есть только у Framework
  Исправление: добавить проверку типа: if ('downloads' in item) { ... }

src/lib/data.ts:156
  TS7006: Parameter 'slug' implicitly has an 'any' type
  Что значит: TypeScript не может вывести тип аргумента
  Исправление: добавить аннотацию: function getFramework(slug: string)`,
        "text",
      ),
      heading(3, "Достижение нуля ошибок перед деплоем"),
      paragraph(
        "Перед каждым деплоем — проверка что TypeScript чистый. Если нашлись ошибки — исправляете, потом деплоите.",
      ),
      codeBlock(
        `/typecheck

Запуск tsc --noEmit...

TypeScript: 0 ошибок.

Можно деплоить.`,
        "text",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "В CI — `tsc --noEmit` запускается при каждом пуше. Если есть ошибки типов — CI падает, деплой не происходит. Это гарантия что в продакшн не попадёт код с типовыми ошибками.",
      ),
      codeBlock(
        `# В GitHub Actions:
- name: Проверка типов
  run: npx tsc --noEmit
  # Если exit code != 0, пайплайн падает

# Строгий режим tsconfig.json:
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noUnusedLocals": true
  }
}`,
        "json",
      ),
      quote(
        "TypeScript без strictNullChecks — это TypeScript с выключенным половиной мозга. Строгий режим ловит баги до запуска.",
      ),
    ]),
    seoTitle: "/typecheck — проверка типов tsc и pyright с пояснениями",
    seoDescription:
      "Команда /typecheck: tsc --noEmit для TypeScript, pyright для Python. Ошибки типов с объяснением и конкретными исправлениями.",
  },

  // ─────────────────────────────────────────────────────────
  // 18. /vps-setup-framework
  // ─────────────────────────────────────────────────────────
  {
    slug: "vps-setup-framework-command",
    description: root([
      heading(2, "Что делает"),
      paragraph(
        "**/vps-setup-framework** устанавливает полный Vibe Framework на VPS за один вызов: hooks, skills, rules, конфиги Claude Code, MCP-серверы для SSH-доступа. После установки все автоматизации работают: security scan на каждый Edit, prettier после сохранения, progress check при остановке.",
      ),
      heading(3, "Синтаксис"),
      codeBlock(
        `# Установка на конкретный сервер
/vps-setup-framework 109.172.36.108

# Через SSH-алиас
/vps-setup-framework stackovervibe

# Claude спросит IP если не указан
/vps-setup-framework`,
        "bash",
      ),
      hr(),
      heading(2, "Пошаговый процесс"),
      list(
        [
          "Подключается к VPS через SSH (прямой IP или MCP SSH-сервер)",
          "Устанавливает Claude Code если не установлен: `npm install -g @anthropic-ai/claude-code`",
          "Создаёт директорию `~/.claude/` со структурой: hooks/, rules/, skills/",
          "Копирует hooks: `security-scan.sh`, `post-edit-format.sh`, `stop-check-debug.sh`, `stop-check-progress.sh`",
          "Копирует rules: `coding-standards.md`, `security.md`, `automation.md`, `anti-mirage.md`",
          "Копирует skills: `docker-deploy`, `project-knowledge`, `code-writing`, `vibe-methodology`",
          "Настраивает `~/.claude/settings.json`: хуки, MCP-серверы",
          "Проверяет установку: все компоненты на месте, права выставлены",
        ],
        true,
      ),
      hr(),
      heading(2, "Примеры использования"),
      heading(3, "Новый VPS для нового проекта"),
      paragraph(
        "Купили новый VPS на Beget — хотите сразу получить полный набор инструментов. `/vps-setup-framework` делает это за 5 минут.",
      ),
      codeBlock(
        `/vps-setup-framework 155.212.144.166

Подключение: 155.212.144.166 (root)
OS: Ubuntu 22.04 LTS

Установка Claude Code...
  npm install -g @anthropic-ai/claude-code  OK

Создание ~/.claude/...
  hooks/           OK (7 хуков)
  rules/           OK (8 правил)
  skills/          OK (12 скиллов)
  settings.json    OK

Настройка MCP-серверов...
  SSH-доступ к серверам  OK

Проверка установки:
  security-scan.sh        OK (права 755)
  post-edit-format.sh     OK
  stop-check-progress.sh  OK
  anti-mirage.md          OK

Vibe Framework установлен. Можно запускать /new-project.`,
        "text",
      ),
      heading(3, "Обновление фреймворка на существующем сервере"),
      paragraph(
        "Вышла новая версия хуков — хотите обновить все серверы. `/vps-setup-framework` перезаписывает конфиги, не трогая проекты.",
      ),
      codeBlock(
        `# Обновление на всех серверах:
/vps-setup-framework zachot
/vps-setup-framework stackovervibe
/vps-setup-framework openclaw

# Или через скрипт:
for server in zachot stackovervibe openclaw; do
  ssh $server "~/.claude/update-framework.sh"
done`,
        "bash",
      ),
      hr(),
      heading(2, "Автоматизация"),
      paragraph(
        "После установки Claude Code на VPS запускается в tmux-сессии с флагами `--max --continue --dangerously-skip-permissions`. Каждый проект — отдельная сессия. `~/start-all.sh` поднимает все сессии разом после рестарта сервера.",
      ),
      codeBlock(
        `# Структура после установки:
~/.claude/
├── settings.json          # конфиг hooks + MCP
├── hooks/
│   ├── security-scan.sh
│   ├── post-edit-format.sh
│   ├── stop-check-debug.sh
│   └── stop-check-progress.sh
├── rules/
│   ├── coding-standards.md
│   ├── security.md
│   ├── automation.md
│   └── anti-mirage.md
└── skills/
    ├── docker-deploy/
    ├── project-knowledge/
    └── code-writing/

# Запуск проекта после установки:
tmux new -s stackovervibe
cd ~/stackovervibe
claude --max --continue --dangerously-skip-permissions`,
        "bash",
      ),
      quote(
        "Vibe Framework — это не инструмент, это среда разработки. Один раз настроил — работает на всех серверах одинаково.",
      ),
    ]),
    seoTitle: "/vps-setup-framework — установка Vibe Framework на VPS",
    seoDescription:
      "Команда /vps-setup-framework: hooks, rules, skills, MCP, конфиги. Полная установка Claude Code окружения на VPS за 5 минут.",
  },
];
