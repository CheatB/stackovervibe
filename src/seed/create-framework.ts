/**
 * Создание первого фреймворка: "Вайбкодинг с нуля — пошаговая методология"
 * Запуск: COMPOSE_PROFILES=seed docker compose run --rm seed npx tsx src/seed/create-framework.ts
 */
import { getPayload } from "payload";
import config from "../../payload.config";
import {
  heading,
  paragraph,
  codeBlock,
  list,
  quote,
  hr,
  root,
} from "./lexical";

const фреймворкДанные = {
  title: "Вайбкодинг с нуля — пошаговая методология",
  slug: "vibecoding-methodology",
  description:
    "Полная методология разработки проектов с помощью AI: от идеи до деплоя. Security Pipeline, Quality Gates, Anti-Mirage. Проверено на реальных проектах.",
  stack: "claude" as const,
  level: "beginner" as const,
  tags: [] as number[], // ID тегов — заполняются по месту (на проде: 27, 26, 29, 28, 30)
  status: "published" as const,
  seoTitle: "Вайбкодинг с нуля — пошаговая методология разработки с AI",
  seoDescription:
    "Полное руководство по вайбкодингу: 7 фаз, Security Pipeline, Quality Gates, Anti-Mirage check. Проверено на 6 проектах.",

  body: root([
    // ======== ПРОСТЫМ ЯЗЫКОМ ========
    heading(2, "Простым языком"),
    paragraph(
      "Вайбкодинг — это когда ты объясняешь AI что хочешь, а он пишет код. Звучит просто, но без системы это превращается в ад: AI делает не то, забывает контекст, пишет мусор, а ты тратишь деньги на токены.",
    ),
    paragraph(
      "Эта методология — рабочий процесс, проверенный на 6 реальных проектах. Ты берёшь идею, проходишь 7 фаз, и на выходе получаешь рабочий продукт на сервере. Не «примерно работает», а конкретно деплоится и работает.",
    ),
    paragraph(
      "Аналогия из жизни: **это как рецепт в кулинарии**. Можно просто кинуть продукты в кастрюлю — иногда получится съедобно. А можно следовать рецепту — и каждый раз будет вкусно. Эта методология — рецепт для создания софта с помощью AI.",
    ),

    hr(),

    // ======== КОМУ ЭТО ========
    heading(2, "Для кого эта методология"),
    list([
      "**Начинающие вайбкодеры** — те, кто пробовал Claude/Cursor и получал мусор вместо кода",
      "**Опытные разработчики** — кто хочет ускорить работу с AI, а не воевать с ним",
      "**Предприниматели** — кто хочет создавать продукты без команды",
    ]),
    paragraph(
      "Не подойдёт: тем, кто хочет нажать одну кнопку и получить готовый продукт. Вайбкодинг — это не магия, а навык. AI пишет код, но ты управляешь процессом.",
    ),

    hr(),

    // ======== 7 ФАЗ ========
    heading(2, "7 фаз: от идеи до деплоя"),
    paragraph(
      "Каждый проект проходит одни и те же фазы. Пропустишь одну — получишь проблемы на следующей. Это как строить дом: нельзя класть крышу без фундамента.",
    ),

    hr(),

    // ======== ФАЗА 1 ========
    heading(2, "Фаза 1: Идея → Спецификация"),
    heading(3, "Что это"),
    paragraph(
      "Берёшь расплывчатую идею («хочу сайт про вайбкодинг») и превращаешь её в конкретный документ: что делает продукт, для кого, какие фичи, что НЕ входит.",
    ),
    heading(3, "Зачем"),
    paragraph(
      "Без спецификации AI будет додумывать за тебя. Он решит что нужна авторизация через 5 соцсетей, 3 языка интерфейса и встроенный чат. А ты хотел лендинг на одну страницу.",
    ),
    heading(3, "Как сделать"),
    list(
      [
        "Опиши идею в 2-3 предложениях — что это, для кого, зачем",
        "Попроси AI задать уточняющие вопросы (он спросит 10-15 вопросов)",
        "Ответь на все вопросы — честно, без «потом решим»",
        "AI создаёт User Spec — документ на 1-2 страницы",
        "Прочитай и утверди. Или попроси поправить.",
      ],
      true,
    ),
    heading(3, "Промпт для старта"),
    codeBlock(
      `Я хочу создать [описание проекта].
Задай мне все необходимые вопросы чтобы составить полную спецификацию.
Спрашивай по одному вопросу за раз.
После всех вопросов — создай User Spec в формате:
- В одном предложении
- Для кого
- Сценарии использования
- Фичи MVP
- Что НЕ входит`,
      "text",
    ),
    heading(3, "Пример"),
    paragraph(
      "Для StackOverVibe спецификация заняла 1 страницу. В ней было: «база знаний по вайбкодингу, ретро-стиль 80-х, SEO-first, путь новичка + каталог инструментов». Этого хватило чтобы AI не уходил в фантазии.",
    ),
    quote(
      "Правило: чем точнее ты опишешь что НЕ нужно, тем лучше будет результат. AI обожает добавлять лишнее.",
    ),

    hr(),

    // ======== ФАЗА 2 ========
    heading(2, "Фаза 2: Спецификация → Техническое задание"),
    heading(3, "Что это"),
    paragraph(
      "User Spec описывает ЧТО делаем. Tech Spec описывает КАК: стек, архитектура, модели данных, API, структура проекта.",
    ),
    heading(3, "Зачем"),
    paragraph(
      "Без Tech Spec AI на каждой задаче будет принимать архитектурные решения заново. Сегодня выберет PostgreSQL, завтра — MongoDB. Сегодня REST API, завтра — GraphQL. Tech Spec фиксирует решения один раз.",
    ),
    heading(3, "Как сделать"),
    list(
      [
        "Скорми AI утверждённый User Spec",
        "Попроси создать Tech Spec: стек + почему, структура, модели данных, API",
        "Обязательно попроси секцию «Решения» — ПОЧЕМУ выбран каждый инструмент",
        "Проверь что стек тебе знаком (или AI сможет с ним работать)",
        "Утверди Tech Spec",
      ],
      true,
    ),
    heading(3, "Промпт"),
    codeBlock(
      `На основе User Spec создай Tech Spec:
1. Стек технологий (+ ПОЧЕМУ каждый выбран)
2. Архитектура (схема, кто с кем общается)
3. Структура проекта (папки и файлы)
4. Модели данных (все сущности и поля)
5. API endpoints
6. Инфраструктура (Docker, деплой)

Важно: каждое решение обоснуй. Не пиши "Next.js" без объяснения почему.`,
      "text",
    ),
    heading(3, "Ключевое правило"),
    paragraph(
      "**Стек выбирается ОДИН РАЗ**. Потом не меняется. Если сомневаешься — выбирай то, с чем у AI больше обучающих данных. Next.js, PostgreSQL, Tailwind — проверенная комбинация.",
    ),

    hr(),

    // ======== ФАЗА 3 ========
    heading(2, "Фаза 3: Техническое задание → Задачи"),
    heading(3, "Что это"),
    paragraph(
      "Разбиваешь Tech Spec на атомарные задачи. Каждая задача — 5-15 минут, одно конкретное действие. «Создать файл X с содержимым Y» — хорошо. «Сделать авторизацию» — плохо.",
    ),
    heading(3, "Зачем"),
    paragraph(
      "AI работает лучше всего с маленькими, конкретными задачами. Дашь большую — потеряет контекст, начнёт фантазировать. Маленькая задача = конкретный результат = можно проверить.",
    ),
    heading(3, "Как сделать"),
    list(
      [
        "Попроси AI разбить Tech Spec на этапы (инфраструктура → данные → страницы → стили)",
        "Каждый этап разбей на задачи по 5-15 минут",
        "Каждая задача должна иметь: номер, описание, зависимости, критерий готовности",
        "Зависимости: «задача 2.3 нужна перед 2.4» — чтобы не делать крышу без стен",
        "Сохрани список в файл — это твой бэклог",
      ],
      true,
    ),
    heading(3, "Формат задачи"),
    codeBlock(
      `| # | Задача | Зависимость | Критерий готовности |
|---|--------|-------------|---------------------|
| 1.2.3 | Написать Dockerfile (multi-stage) | ← 1.1.1 | docker compose up работает |
| 2.1.1 | Создать коллекцию Users | ← 1.2.3 | /admin показывает Users |`,
      "markdown",
    ),
    quote(
      "Совет: задачи нумеруй как 1.1.1, 1.1.2, 2.1.1 — по этапу.блоку.задаче. Так видно прогресс и зависимости.",
    ),

    hr(),

    // ======== ФАЗА 4 ========
    heading(2, "Фаза 4: Настройка окружения"),
    heading(3, "Что это"),
    paragraph(
      "Настраиваешь инструменты, которые будут помогать AI писать качественный код: хуки, правила, скиллы. Это как настроить станок перед работой.",
    ),
    heading(3, "Минимальный набор"),
    list([
      "**CLAUDE.md** — файл в корне проекта с описанием проекта, стека, правил. AI читает его при каждом запуске",
      "**Project Knowledge** — папка `docs/` с архитектурой, паттернами, деплоем",
      "**Хук: prettier** — автоформатирование после каждого изменения файла",
      "**Хук: security-scan** — проверка на секреты перед каждым коммитом",
      "**Правило: anti-mirage** — проверка что AI не ссылается на несуществующие файлы и функции",
    ]),
    heading(3, "CLAUDE.md — самый важный файл"),
    codeBlock(
      `# Название проекта

Одно предложение описания.

## Стек
Next.js 15, Payload CMS, PostgreSQL, Tailwind CSS

## Правила
- Код, комментарии, переменные — на русском
- DRY, KISS, YAGNI
- Коммиты: conventional commits (feat/fix/refactor)

## Прогресс
**Текущая задача:** 2.3.1 — Создать страницу каталога
**Следующая:** 2.3.2 — Фильтры по типу

## Ссылки
- docs/project-knowledge/ — архитектура и паттерны
- docs/tasks-detailed.md — список задач`,
      "markdown",
    ),
    paragraph(
      "**Секция «Прогресс» — ключевая.** AI забывает контекст между сессиями. Прогресс в CLAUDE.md — это его память. Обновляй после каждого блока задач.",
    ),
    heading(3, "Хуки — автоматизация качества"),
    paragraph(
      "Хуки запускаются автоматически при определённых действиях AI. Не нужно напоминать «проверь форматирование» — хук сделает сам.",
    ),
    codeBlock(
      `# settings.json — конфиг Claude Code
{
  "hooks": {
    "PostToolUse": [{
      "matcher": "Edit|Write",
      "command": "npx prettier --write $FILE"
    }],
    "Stop": [{
      "command": "bash check-debug.sh"
    }]
  }
}`,
      "json",
    ),

    hr(),

    // ======== ФАЗА 5 ========
    heading(2, "Фаза 5: Разработка — блок за блоком"),
    heading(3, "Что это"),
    paragraph(
      "Берёшь задачи из бэклога и выполняешь по порядку. Каждый блок: 3-5 задач → проверка → коммит → обновление прогресса.",
    ),
    heading(3, "Цикл одного блока"),
    list(
      [
        "**Читаешь CLAUDE.md** — AI вспоминает контекст и текущую задачу",
        "**Выполняешь 3-5 задач** — по порядку, каждую проверяя",
        "**Коммитишь** — `feat: добавить каталог инструментов`",
        "**Обновляешь прогресс в CLAUDE.md** — что сделано, что дальше",
        "**Если контекст >70%** — новая сессия с чтением CLAUDE.md",
      ],
      true,
    ),
    heading(3, "Промпт для начала блока"),
    codeBlock(
      `Прочитай CLAUDE.md и docs/tasks-detailed.md.
Найди первую незавершённую задачу.
Выполни её и следующие 3-4 задачи этого блока.
После каждой задачи — обнови прогресс.`,
      "text",
    ),
    heading(3, "Правило 5 минут"),
    paragraph(
      "Если AI застрял на задаче больше 5 минут — остановись. Либо задача слишком большая (разбей), либо не хватает контекста (добавь в CLAUDE.md), либо AI галлюцинирует (проверь anti-mirage).",
    ),
    heading(3, "Anti-Mirage — защита от галлюцинаций"),
    paragraph(
      "AI регулярно ссылается на файлы и функции, которых не существует. Это «миражи» — самая частая причина ошибок.",
    ),
    list([
      "Каждый `import` ссылается на **существующий** файл?",
      "Каждая вызываемая функция **существует** в импортируемом модуле?",
      "Все зависимости указаны в `package.json`?",
      "Все env-переменные описаны в `.env.example`?",
    ]),
    quote(
      "Правило: после написания >20 строк кода — проверь все импорты. AI врёт с абсолютно уверенным видом.",
    ),

    hr(),

    // ======== ФАЗА 6 ========
    heading(2, "Фаза 6: Деплой"),
    heading(3, "Что это"),
    paragraph(
      "Выкладываешь проект на сервер чтобы он работал в интернете. Docker-контейнер + Nginx + SSL — стандартная связка.",
    ),
    heading(3, "Минимальный стек деплоя"),
    list([
      "**VPS** — любой облачный сервер (Beget, Timeweb, Hetzner, DigitalOcean)",
      "**Docker Compose** — запуск app + БД одной командой",
      "**Nginx** — reverse proxy, SSL, отдача статики",
      "**Let's Encrypt** — бесплатный SSL-сертификат",
      "**GitHub Actions** — push в main → автоматический деплой",
    ]),
    heading(3, "Docker Compose — минимум"),
    codeBlock(
      `# docker-compose.yml
services:
  app:
    build: .
    ports:
      - "3000:3000"
    env_file: .env
    depends_on:
      postgres:
        condition: service_healthy

  postgres:
    image: postgres:16-alpine
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: \${POSTGRES_USER}
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \${POSTGRES_USER}"]
      interval: 5s

volumes:
  pgdata:`,
      "yaml",
    ),
    heading(3, "CI/CD — деплой по пушу"),
    codeBlock(
      `# .github/workflows/deploy.yml
name: Deploy
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: self-hosted
    steps:
      - run: |
          ssh server "cd ~/project && git pull && \\
            docker compose down && \\
            docker compose up -d --build"`,
      "yaml",
    ),
    paragraph(
      "Этого достаточно. Пушнул в main — через 2 минуты на сервере новая версия. Никаких Kubernetes, никаких оркестраторов. Простота.",
    ),

    hr(),

    // ======== ФАЗА 7 ========
    heading(2, "Фаза 7: Итерация и контент"),
    heading(3, "Что это"),
    paragraph(
      "Проект задеплоен, но это только начало. Добавляешь контент, фиксишь баги, добавляешь фичи — тем же методом: задача → выполнение → коммит → деплой.",
    ),
    heading(3, "Обогащение контента"),
    paragraph(
      "Самый эффективный способ — seed-скрипты. Готовишь контент в коде, запускаешь скрипт — он заливает всё в CMS. Можно обновить 47 записей за 30 секунд вместо ручного копирования.",
    ),
    codeBlock(
      `// Пример: обновить описание инструмента
const payload = await getPayload({ config });

await payload.update({
  collection: "tools",
  id: инструмент.id,
  data: {
    description: richTextContent, // Lexical JSON
    seoTitle: "Название — ключевые слова",
    seoDescription: "Описание для поисковиков (150-160 символов)",
  },
});`,
      "typescript",
    ),
    heading(3, "SEO — главный канал трафика"),
    list([
      "Каждая страница — отдельный поисковый запрос",
      "`seoTitle` — 60 символов, с ключевыми словами",
      "`seoDescription` — 155 символов, с призывом к действию",
      "JSON-LD разметка (Article, HowTo, BreadcrumbList)",
      "sitemap.xml обновляется автоматически",
    ]),

    hr(),

    // ======== SECURITY PIPELINE ========
    heading(2, "Фаза 4.5: Security Pipeline"),
    paragraph(
      "Безопасность — не финальная проверка, а встроенный этап. Три инструмента работают автоматически на каждом коммите и PR.",
    ),

    heading(3, "Vet — LLM-верификация кода"),
    paragraph(
      "**Vet** (verify-everything) — CLI-инструмент, который анализирует код через Claude. Ловит то, что не видят линтеры: hardcoded секреты в нестандартных местах, race conditions, утечки ресурсов, небезопасный код.",
    ),
    list([
      "**Pre-commit hook** — проверяет каждый коммит автоматически",
      "**CI/CD** — анализирует все изменения в Pull Request",
      "**Еженедельный аудит** — полный скан проекта по расписанию",
    ]),
    codeBlock(
      `# Локальная проверка
vet "описание изменений" --agentic --quiet

# Security-фокус
vet "security" --enabled-issue-codes hardcoded_secret insecure_code race_condition`,
      "bash",
    ),

    heading(3, "agents-lint — свежесть CLAUDE.md"),
    paragraph(
      "CLAUDE.md врёт — это нормально. Проект развивается, пути меняются, скрипты переименовываются. **agents-lint** проверяет что CLAUDE.md не протух: все пути существуют, скрипты запускаются, секции Setup/Build на месте.",
    ),
    codeBlock(
      `# Проверка свежесть
npx agents-lint

# Результат: Freshness Score 0-100
# < 80 = CLAUDE.md нужно обновить`,
      "bash",
    ),

    heading(3, "Автоматизация: три уровня"),
    list(
      [
        "**Коммит** — pre-commit hook запускает vet + agents-lint автоматически",
        "**Pull Request** — GitHub Actions: vet-review + agents-lint + security-scan",
        "**Еженедельно** — полный аудит: npm audit + поиск секретов + vet security",
      ],
      true,
    ),
    paragraph(
      "Все шаблоны хранятся централизованно. При создании нового проекта — одна команда копирует hook и CI workflows.",
    ),
    quote(
      "Правило: security-инструменты не замедляют разработку — они работают в фоне. Ты узнаёшь о проблемах ДО того, как они попадут в прод.",
    ),

    hr(),

    // ======== ЧАСТЫЕ ОШИБКИ ========
    heading(2, "Частые ошибки (и как их избежать)"),

    heading(3, "1. «Сделай мне приложение»"),
    paragraph(
      "Плохо: один промпт на весь проект. AI потеряет контекст на 3-й минуте. **Решение:** разбивай на фазы и задачи.",
    ),

    heading(3, "2. Нет CLAUDE.md"),
    paragraph(
      "AI забывает всё между сессиями. Без CLAUDE.md каждая сессия начинается с нуля. **Решение:** CLAUDE.md + секция «Прогресс».",
    ),

    heading(3, "3. Доверие AI без проверки"),
    paragraph(
      "AI пишет `import { calcPrice } from './utils'` — а файла utils.ts нет. **Решение:** anti-mirage check после каждого блока кода.",
    ),

    heading(3, "4. Слишком большие задачи"),
    paragraph(
      "«Сделай авторизацию» — AI напишет 500 строк с ошибками. «Создай коллекцию Users с полями email, role, telegramId» — AI напишет 20 строк идеально. **Решение:** задачи по 5-15 минут.",
    ),

    heading(3, "5. Нет коммитов"),
    paragraph(
      "Написал 1000 строк без коммита — что-то сломалось — не можешь откатить. **Решение:** коммит после каждого блока (3-5 задач).",
    ),

    heading(3, "6. Менять стек на ходу"),
    paragraph(
      "«А давай вместо PostgreSQL попробуем MongoDB» — после 2 недель разработки. **Решение:** стек фиксируется на фазе 2 и не меняется.",
    ),

    hr(),

    // ======== РЕАЛЬНЫЙ ПРИМЕР ========
    heading(2, "Реальный пример: StackOverVibe"),
    paragraph(
      "Этот сайт (stackovervibe.ru) создан по этой методологии. Весь процесс:",
    ),
    list([
      "**Фаза 1:** User Spec — 1 страница, 30 минут",
      "**Фаза 2:** Tech Spec — выбрали Next.js + Payload CMS + PostgreSQL, 1 час",
      "**Фаза 3:** 180+ атомарных задач, разбитых на 10 этапов",
      "**Фаза 4:** CLAUDE.md + project-knowledge + хуки (prettier, security-scan)",
      "**Фаза 5:** 10 фаз разработки, ~50 коммитов",
      "**Фаза 6:** Docker + Nginx + SSL + CI/CD (GitHub Actions)",
      "**Фаза 7:** Обогащение контента — 47 инструментов + 8 гайдов за один вечер",
    ]),
    paragraph(
      "Результат: полноценный сайт с CMS, UGC, Q&A, поиском, аналитикой, SEO — за несколько недель. Один человек + AI.",
    ),

    hr(),

    // ======== ЧЕКЛИСТ ========
    heading(2, "Чеклист: готов ли ты начать"),
    list([
      "Есть идея проекта (хотя бы расплывчатая)",
      "Установлен Claude Code (или Cursor, или другой AI-инструмент)",
      "Есть VPS или готовность его купить (от 300 руб/мес)",
      "Есть 2-4 часа в день на проект",
      "Готов читать что пишет AI, а не слепо копировать",
    ]),

    hr(),

    // ======== ИТОГО ========
    heading(2, "Итого"),
    paragraph(
      "Вайбкодинг работает когда есть система. Без системы — это лотерея: иногда повезёт, чаще нет.",
    ),
    paragraph("Система простая:"),
    list(
      [
        "**Идея → User Spec** — что делаем",
        "**User Spec → Tech Spec** — как делаем",
        "**Tech Spec → Задачи** — в каком порядке",
        "**Настройка** — CLAUDE.md, хуки, правила",
        "**Разработка** — блок за блоком, коммит за коммитом",
        "**Деплой** — Docker + Nginx + CI/CD",
        "**Итерация** — контент, фиксы, новые фичи",
      ],
      true,
    ),
    quote(
      "Не пытайся запомнить всё. Закинь эту методологию в Claude — он напомнит что делать на каждом шаге.",
    ),
  ]),
};

async function создатьФреймворк() {
  const payload = await getPayload({ config });

  // Проверяем, есть ли уже
  const { docs } = await payload.find({
    collection: "frameworks",
    where: { slug: { equals: фреймворкДанные.slug } },
    limit: 1,
  });

  // Ищем теги по slug
  const нужныеТеги = [
    "vibe-coding",
    "claude-code",
    "skills",
    "hooks",
    "commands",
  ];
  const { docs: найденныеТеги } = await payload.find({
    collection: "tags",
    where: { slug: { in: нужныеТеги } },
    limit: 10,
  });
  const tagIds = найденныеТеги.map((t) => t.id);
  console.log(`Теги: найдено ${tagIds.length} из ${нужныеТеги.length}`);

  if (docs.length > 0) {
    // Обновляем
    await payload.update({
      collection: "frameworks",
      id: docs[0].id,
      data: {
        title: фреймворкДанные.title,
        description: фреймворкДанные.description,
        body: фреймворкДанные.body as unknown as Record<string, unknown>,
        stack: фреймворкДанные.stack,
        level: фреймворкДанные.level,
        tags: tagIds.length > 0 ? tagIds : undefined,
        seoTitle: фреймворкДанные.seoTitle,
        seoDescription: фреймворкДанные.seoDescription,
        status: фреймворкДанные.status,
      },
    });
    console.log(
      `Фреймворк обновлён: ${фреймворкДанные.slug} (id: ${docs[0].id})`,
    );
  } else {
    // Ищем пользователя-автора (admin)
    const { docs: users } = await payload.find({
      collection: "users",
      where: { role: { equals: "admin" } },
      limit: 1,
    });

    const authorId = users[0]?.id || 1;

    const doc = await payload.create({
      collection: "frameworks",
      data: {
        title: фреймворкДанные.title,
        slug: фреймворкДанные.slug,
        description: фреймворкДанные.description,
        body: фреймворкДанные.body as unknown as Record<string, unknown>,
        author: authorId,
        stack: фреймворкДанные.stack,
        level: фреймворкДанные.level,
        tags: tagIds.length > 0 ? tagIds : undefined,
        seoTitle: фреймворкДанные.seoTitle,
        seoDescription: фреймворкДанные.seoDescription,
        status: фреймворкДанные.status,
      },
    });
    console.log(`Фреймворк создан: ${doc.slug} (id: ${doc.id})`);
  }

  process.exit(0);
}

создатьФреймворк().catch((e) => {
  console.error("Ошибка:", e.message);
  process.exit(1);
});
